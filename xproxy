#!/usr/bin/env bash


_XPROXY_CACHE="$HOME/.xproxy_cache"
_XPROXY_OS="$(uname -s)"

_XPROXY_ENV="http_proxy https_proxy ftp_proxy rsync_proxy all_proxy \
	     HTTP_PROXY HTTPS_PROXY FTP_PROXY RSYNC_PROXY ALL_PROXY"

_XPROXY_NO_PROXY="localhost,127.0.0.1,::1,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,*.local"

if [ -f "$_XPROXY_CACHE" ]; then
	. "$_XPROXY_CACHE"
fi

_xproxy_set() {

	local proxy_profile="$1"
	local local_mode="$2"

	# proxy variables inside the profile file
	local SOCKS_ENABLE  
	local SOCKS_HOST="127.0.0.1" 
	local SOCKS_PORT="10808"  
	local SOCKS_VERSION="socks5h"
	local HTTP_ENABLE 
	local HTTP_HOST="127.0.0.1"
	local HTTP_PORT="10808" 

	if [ ! -f "$proxy_profile" ]; then
		echo "$proxy_profile not found!" >& 2
		return 1;
	fi
	. "$proxy_profile"

	echo "profile loaded from $proxy_profile"
	
	local proxy_url="" 
	if [ "$SOCKS_ENABLE" = "true" ]; then
		proxy_url="$SOCKS_VERSION://$SOCKS_HOST:$SOCKS_PORT"
	fi 	

	if [ "$HTTP_ENABLE" = "true" ]; then
		proxy_url="http://$HTTP_HOST:$HTTP_PORT"
	fi	

	if [ -z "$proxy_url" ]; then
		echo "socks and http are both disabled, nothing to do..."
		return 0
	fi

	# set proxy settings via environmental variables for current shell instance
	for env in $_XPROXY_ENV; do
		export "$env"="$proxy_url"
	done
	export no_proxy="${_XPROXY_NO_PROXY}"
	export NO_PROXY="${_XPROXY_NO_PROXY}"

	echo "[ENV] variables are set to $proxy_url"

	# if in local mode do not apply system-wide settings
	if [ "$local_mode" = "true" ]; then
		return 0;
	fi

	# set proxy settings for future shell instances
	# WARNING: other current shell instances won't follow these proxy settings
	echo "# This file is automatically created by xproxy, DO NOT EDIT!" > "$_XPROXY_CACHE"
	for env in $_XPROXY_ENV; do
		echo "export "$env"=\"$proxy_url\"" >> "$_XPROXY_CACHE"
	done
	echo "export no_proxy=\"$_XPROXY_NO_PROXY\"" >> "$_XPROXY_CACHE"
	echo "export NO_PROXY=\"$_XPROXY_NO_PROXY\"" >> "$_XPROXY_CACHE"

	echo "[CACHE] "$_XPROXY_CACHE" created for future shells"

	if [ "$_XPROXY_OS" = "Linux" ]; then
		# set proxy setting for gnome compatibles
		if command -v gsettings > /dev/null 2>&1; then
			gsettings set org.gnome.system.proxy mode 'manual'
			echo "[GNOME] proxy mode set to 'manual'"
			# set socks setting if enabled
			if [ "$SOCKS_ENABLE" = "true" ]; then
				gsettings set org.gnome.system.proxy.socks host "$SOCKS_HOST"
				echo "[GNOME] socks host set to "$SOCKS_HOST""

				gsettings set org.gnome.system.proxy.socks port "$SOCKS_PORT"
				echo "[GNOME] socks port set to "$SOCKS_PORT""
			else 
				# clean the socks settings to prevent any intervention
				gsettings set org.gnome.system.proxy.socks host ""
				echo "[GNOME] socks host cleared" 
				gsettings set org.gnome.system.proxy.socks port 0
				echo "[GNOME] socks port cleared"
			fi

			local PROTOS="http https ftp"
			# set other protocols to http proxy if enabled
			if [ "$HTTP_ENABLE" = "true" ]; then

				for proto in $PROTOS; do

					gsettings set org.gnome.system.proxy."$proto" host "$HTTP_HOST"
					echo "[GNOME] "$proto" host set to "$HTTP_HOST""

					gsettings set org.gnome.system.proxy."$proto" port "$HTTP_PORT"
					echo "[GNOME] "$proto" port set to "$HTTP_PORT""

				done
			else
				# clean the other settings to prevent any intervention
				for proto in $PROTOS; do

					gsettings set org.gnome.system.proxy."$proto" host ""
					echo "[GNOME] "$proto" host cleared" 

					gsettings set org.gnome.system.proxy."$proto" port 0
					echo "[GNOME] "$proto" port cleared"

				done
			fi

			gsettings set org.gnome.system.proxy ignore-hosts "['$_XPROXY_NO_PROXY']"
			echo  "[GNOME] ignored-hosts set to "$_XPROXY_NO_PROXY""
		fi

		# set proxy settings for kde compatibles
		if command -v kwriteconfig6 > /dev/null 2>&1; then

			kwriteconfig6 --file kioslaverc --group "Proxy Settings" --key ProxyType 1
			echo "[KDE] proxy type set to 1"

			# set socks setting if enabled
			if [ "$SOCKS_ENABLE" = "true" ]; then

				kwriteconfig6 --file kioslaverc --group "Proxy Settings" \
					      --key socksProxy "$SOCKS_VERSION://"$SOCKS_HOST":"$SOCKS_PORT""
				echo "[KDE] socks proxy set to "$SOCKS_VERSION://"$SOCKS_HOST":"$SOCKS_PORT"""

			else 

				kwriteconfig6 --file kioslaverc --group "Proxy Settings" --key socksProxy ""
				echo "[KDE] socks proxy cleared"

			fi

			if [ "$HTTP_ENABLE" = "true" ]; then

				for proto in $PROTOS; do

					kwriteconfig6 --file kioslaverc --group "Proxy Settings" \
						      --key "$proto"Proxy "http://"$HTTP_HOST":"$HTTP_PORT""
					echo "[KDE] "$proto" proxy set to "http://"$HTTP_HOST":"$HTTP_PORT"""

				done
			else
				# clean the other settings to prevent any intervention
				for proto in $PROTOS; do

					kwriteconfig6 --file kioslaverc --group "Proxy Settings" --key "$proto"Proxy ""
					echo "[KDE] $proto proxy cleared"

				done
			fi

			# Set ignored hosts
			kwriteconfig6 --file kioslaverc --group "Proxy Settings" --key NoProxyFor "$_XPROXY_NO_PROXY"
			echo "[KDE] NoProxyFor set to "$_XPROXY_NO_PROXY""

			# apply changes by restarting kde's network settings
			dbus-send --type=signal /KIO/Scheduler org.kde.KIO.Scheduler.reparseSlaveConfiguration string:""

		fi
	elif [ "$_XPROXY_OS" = "Darwin" ]; then
		# set proxy settings for macOS
		if command -v networksetup > /dev/null 2>&1; then
			# macOS expects spaces instead of commas for bypass domains
			local mac_bypass=$(echo "$_XPROXY_NO_PROXY" | tr ',' ' ')

			# Loop through all active network interfaces (e.g., Wi-Fi, Ethernet)
			while IFS= read -r service; do
				if [ "$SOCKS_ENABLE" = "true" ]; then
					networksetup -setsocksfirewallproxy "$service" "$SOCKS_HOST" "$SOCKS_PORT" off >/dev/null 2>&1
					networksetup -setsocksfirewallproxystate "$service" on >/dev/null 2>&1
				else
					networksetup -setsocksfirewallproxystate "$service" off >/dev/null 2>&1
				fi

				if [ "$HTTP_ENABLE" = "true" ]; then
					networksetup -setwebproxy "$service" "$HTTP_HOST" "$HTTP_PORT" off >/dev/null 2>&1
					networksetup -setsecurewebproxy "$service" "$HTTP_HOST" "$HTTP_PORT" off >/dev/null 2>&1
					networksetup -setftpproxy "$service" "$HTTP_HOST" "$HTTP_PORT" off >/dev/null 2>&1
					networksetup -setwebproxystate "$service" on >/dev/null 2>&1
					networksetup -setsecurewebproxystate "$service" on >/dev/null 2>&1
					networksetup -setftpproxystate "$service" on >/dev/null 2>&1
				else
					networksetup -setwebproxystate "$service" off >/dev/null 2>&1
					networksetup -setsecurewebproxystate "$service" off >/dev/null 2>&1
					networksetup -setftpproxystate "$service" off >/dev/null 2>&1
				fi
				
				# Set proxy bypass domains
				networksetup -setproxybypassdomains "$service" $mac_bypass >/dev/null 2>&1

			done <<< "$(networksetup -listallnetworkservices | grep -v '^\*')"
			echo "[MACOS] proxy settings applied to all network services"
		fi
	fi
}

_xproxy_unset() {

	local local_mode="$1"

	# unset proxy settings via environment variables for current shell instance
	for env in $_XPROXY_ENV; do
		unset "$env"
	done
	unset no_proxy
	unset NO_PROXY
	echo "[ENV] variables unset"

	# if in local_mode then do not apply system-wide settings
	if [ "$local_mode" = "true" ]; then
		return 0;
	fi

	# unset proxy settings for future shell instances
	# WARNING: other current shell instances will continue to use the previous proxy settings
	if [ -f "$_XPROXY_CACHE" ]; then
		rm -f "$_XPROXY_CACHE"
		echo "[CACHE] "$_XPROXY_CACHE" deleted"
	fi

	if [ "$_XPROXY_OS" = "Linux" ]; then
		# unset proxy setting for gnome compatibles
		if command -v gsettings > /dev/null 2>&1; then
			gsettings set org.gnome.system.proxy mode 'none'
			echo "[GNOME] proxy mode set to 'none'"
		fi

		# set proxy settings for kde compatibles
		if command -v kwriteconfig6 > /dev/null 2>&1; then
			kwriteconfig6 --file kioslaverc --group "Proxy Settings" --key ProxyType 0
			echo "[KDE] proxy type set to 0"
			# apply changes by restarting kde's network settings
			dbus-send --type=signal /KIO/Scheduler org.kde.KIO.Scheduler.reparseSlaveConfiguration string:""
		fi
	elif [ "$_XPROXY_OS" = "Darwin" ]; then
		# unset proxy settings for macOS
		if command -v networksetup > /dev/null 2>&1; then
			while IFS= read -r service; do
				networksetup -setsocksfirewallproxystate "$service" off >/dev/null 2>&1
				networksetup -setwebproxystate "$service" off >/dev/null 2>&1
				networksetup -setsecurewebproxystate "$service" off >/dev/null 2>&1
				networksetup -setftpproxystate "$service" off >/dev/null 2>&1
				networksetup -setproxybypassdomains "$service" Empty >/dev/null 2>&1
			done <<< "$(networksetup -listallnetworkservices | grep -v '^\*')"
			echo "[MACOS] proxy disabled for all network services"
		fi
	fi
}

_xproxy_status() {

	local local_mode=$1;

	# Initialize color variables if tput is in PATH
	if command -v tput > /dev/null 2>&1; then	
		local RED=$(tput setaf 1)
		local RESET=$(tput sgr0)
	fi

	# check proxy environment variable settings
	for env in $_XPROXY_ENV; do
		
		echo -n "[ENV] "
		if eval "[ -n \"\$$env\" ]"; then 
			eval "echo "$env = \$$env""
		else 
			echo "${RED}${env} is NOT set${RESET}"
		fi
		
	done

	# if in local mode then do not check system-wide settings
	if [ "$local_mode" = "true" ]; then
		return 0;
	fi

	# check existance of cache file for future shells 
	echo -n "[CACHE] "
	if [ -f "$_XPROXY_CACHE" ]; then
		echo "$_XPROXY_CACHE exists"
	else 
		echo "${RED}$_XPROXY_CACHE does NOT exist${RESET}"
	fi

	if [ "$_XPROXY_OS" = "Linux" ]; then
		# check gnome proxy settings
		if command -v gsettings > /dev/null 2>&1; then
			echo -n "[GNOME] "
			if [ $(gsettings get org.gnome.system.proxy mode) = "'manual'" ]; then
				echo "setting is set"
			else 
				echo "${RED}setting is NOT set${RESET}"
			fi
		fi

		# check kde proxy settings
		if command -v kreadconfig6 > /dev/null 2>&1; then
			echo -n "[KDE] "
			if [ $(kreadconfig6 --file kioslaverc --group "Proxy Settings" --key ProxyType) = "1" ]; then
				echo "setting is set"
			else 
				echo "${RED}setting is NOT set${RESET}"
			fi
		fi
	elif [ "$_XPROXY_OS" = "Darwin" ]; then
		# check macOS proxy settings
		if command -v networksetup > /dev/null 2>&1; then
			echo -n "[MACOS] "
			# We'll just check Wi-Fi as a generic indicator for macOS status
			local mac_status=$(networksetup -getsocksfirewallproxy Wi-Fi 2>/dev/null | grep "^Enabled: Yes")
			local mac_http_status=$(networksetup -getwebproxy Wi-Fi 2>/dev/null | grep "^Enabled: Yes")
			if [ -n "$mac_status" ] || [ -n "$mac_http_status" ]; then
				echo "setting is set"
			else 
				echo "${RED}setting is NOT set${RESET}"
			fi
		fi
	fi
}

xproxy() {
	
	# ZSH ONLY: to make it behave like a normal shell
	if [ -n "$ZSH_VERSION" ]; then
		local zsh_mode=$(emulate)
		emulate ksh
	fi

	local cmd
	local profile_arg="$HOME/.xproxy_profile"
	local local_only="false"

	# parsing arguments
	while [ $# -gt 0 ]; do
		case "$1" in
			"-l"|"--local")
				local_only="true"
				shift
				;;
			"set"|"unset"|"status"|"stat")
				cmd="$1"
				shift
				;;
			*)
				profile_arg="$1"
				shift
				;;
		esac
	done


	case "$cmd" in
	"set")
		_xproxy_set "$profile_arg" "$local_only"
	;;
	"unset")
		_xproxy_unset "$local_only"
	;;
	"status"|"stat")
		_xproxy_status "$local_only"
	;;
	*)
		echo -e "Usage:\nxproxy\n\tset [profile-file] [--local]\n\tunset [--local]\n\tstatus"
	;;
	esac

	# restore ZSH to whatever it was before this script
	if [ -n "$zsh_mode" ]; then
		emulate "$zsh_mode"
	fi
}
